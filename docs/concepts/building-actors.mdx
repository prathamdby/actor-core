---
title: Building Actors
icon: square-plus
---

ActorCore makes it easy to build stateful, realtime backends. Let's start by creating a simple actor.

## Quick Start Example

Here's a complete chat room actor that maintains state and handles messages:

```typescript chat_room.ts
import { Actor, type Rpc } from "actor-core";

// Define the actor's state structure
interface State {
  messages: Array<{
    sender: string;
    text: string;
    timestamp: number;
  }>;
}

export default class ChatRoom extends Actor<State> {
  // Initialize state when the actor is first created
  _onInitialize(): State {
    return { messages: [] };
  }

  // RPC method clients can call
  sendMessage(rpc: Rpc<ChatRoom>, sender: string, text: string) {
    // Update state
    this._state.messages.push({
      sender,
      text,
      timestamp: Date.now()
    });
    
    // Broadcast to all connected clients
    this._broadcast("newMessage", { 
      sender, 
      text,
      timestamp: Date.now()
    });
  }
  
  // RPC to get chat history
  getHistory(rpc: Rpc<ChatRoom>) {
    return this._state.messages;
  }
}
```

## Key Actor Components

### State

Actors maintain state that's stored in memory and automatically persisted. State is defined as a TypeScript interface and initialized in the `_onInitialize` method:

```typescript
interface State {
  count: number;
}

export default class Counter extends Actor<State> {
  _onInitialize(): State {
    return { count: 0 };
  }
}
```

Update state by modifying `this._state`:

```typescript
increment(rpc: Rpc<Counter>) {
  this._state.count += 1;
}
```

Learn more about [state management](/concepts/state).

### Remote Procedure Calls (RPCs)

RPCs are methods on your actor class that clients can call. They must accept a `rpc` parameter as the first argument:

```typescript
multiplyByTwo(rpc: Rpc<Example>, x: number) {
  return x * 2;
}
```

Private methods starting with `_` or `#` cannot be called by clients:

```typescript
// Private - not callable by clients
#calculateFee(amount: number) {
  return amount * 0.05;
}

// Public - callable by clients
processPayment(rpc: Rpc<Example>, amount: number) {
  const fee = this.#calculateFee(amount);
  // Process payment logic...
  return { amount, fee };
}
```

Learn more about [RPCs](/concepts/rpc).

### Events

Actors can broadcast events to connected clients:

```typescript
addItem(rpc: Rpc<Inventory>, item: string) {
  // Add to state
  this._state.items.push(item);
  
  // Notify all clients about the new item
  this._broadcast("itemAdded", { item });
}
```

You can also send events to specific clients:

```typescript
// Send to a specific connection
const connection = this._connections.find(c => c.id === userId);
if (connection) {
  connection.send("privateMessage", { text: "Only you can see this" });
}
```

Learn more about [events](/concepts/events).

## Actor Tags

Tags are key-value pairs attached to actors that serve two purposes:

1. **Actor Discovery**: Find specific actors using `client.get(tags)`
2. **Organization**: Group related actors for management purposes

The `name` tag is required and identifies the actor type.

```typescript
// Tags for a chat room actor
{
  name: 'chat_room',
  channel: 'general'
}
```

### Common Tag Patterns

Tags help clients find the right actor instance. Here are some common patterns:

```typescript
// Game room by code
const gameRoom = await client.get<GameRoom>({
  name: 'game_room',
  roomCode: 'ABC123'
});

// User-specific actor
const userProfile = await client.get<UserProfile>({
  name: 'user_profile',
  userId: '1234'
});

// Document with workspace
const document = await client.get<Document>({
  name: 'document',
  workspaceId: 'team-alpha',
  documentId: 'budget-2024'
});
```

## Actor Lifecycle

Actors are created automatically when needed and persist until explicitly shutdown.

To shut down an actor, use `this._shutdown()` from within an RPC:

```typescript
closeRoom(rpc: Rpc<ChatRoom>) {
  // Do any cleanup needed
  this._broadcast("roomClosed");
  
  // Shutdown the actor
  this._shutdown();
}
```

Learn more about the [actor lifecycle](/concepts/lifecycle).

## Next Steps

- [Interacting with Actors](/concepts/interacting-with-actors) - Learn how to connect to actors from clients
- [State in Detail](/concepts/state) - Deep dive into actor state management
- [RPCs in Detail](/concepts/rpc) - Learn more about remote procedure calls
- [Events in Detail](/concepts/events) - Learn more about realtime events
